/**
 * PostPress AI — Admin JS
 * Path: assets/js/admin.js
 *
 * ========= CHANGE LOG =========
 * 2025-10-19: Added provider tracing for preview responses by sniffing `<!-- provider: X -->` in returned HTML. // CHANGED:
 * 2025-10-19: Confirmed robust ajaxurl fallback (ppaAdmin.ajaxurl → window.ajaxurl → /wp-admin/admin-ajax.php). // CHANGED:
 * =================================
 *
 * Notes:
 * - Logs are namespaced with "PPA:" as per P1.
 * - Nonce header: X-PPA-Nonce when #ppa-nonce is present.
 * - Tolerant JSON parsing for multiple shapes (json.html, json.result.html, json.data.html, json.content, json.preview).
 * - This version only implements Improvement #1 from Wayne’s list: provider tracing in Preview flow.
 */

(function () {
  'use strict';

  // Abort if composer root is missing (defensive)
  var root = document.getElementById('ppa-composer');
  if (!root) {
    console.info('PPA: composer root not found, admin.js is idle');
    return;
  }

  // ---- Helpers -------------------------------------------------------------

  function $(sel, ctx) {
    return (ctx || document).querySelector(sel);
  }

  function $all(sel, ctx) {
    return Array.prototype.slice.call((ctx || document).querySelectorAll(sel) || []);
  }

  function getAjaxUrl() {
    // Primary from localized script, fallback to window.ajaxurl, then default path. // CHANGED:
    if (window.ppaAdmin && window.ppaAdmin.ajaxurl) return window.ppaAdmin.ajaxurl; // CHANGED:
    if (window.ajaxurl) return window.ajaxurl; // CHANGED:
    return '/wp-admin/admin-ajax.php'; // CHANGED:
  }

  function getNonce() {
    var el = $('#ppa-nonce');
    return el ? String(el.value || '').trim() : '';
  }

  function jsonTryParse(text) {
    try {
      return JSON.parse(text);
    } catch (e) {
      console.info('PPA: JSON parse failed, returning raw text'); // CHANGED:
      return { raw: String(text || '') };
    }
  }

  function setPreview(html) {
    var pane = $('#ppa-preview-pane');
    if (!pane) return;
    pane.innerHTML = html;
  }

  // Extract `provider` from an HTML comment like: <!-- provider: local-fallback --> // CHANGED:
  function extractProviderFromHtml(html) { // CHANGED:
    if (typeof html !== 'string') return ''; // CHANGED:
    var m = html.match(/<!--\s*provider:\s*([a-z0-9._-]+)\s*-->/i); // CHANGED:
    return m ? m[1] : ''; // CHANGED:
  }

  function buildPayload() {
    var subject = $('#ppa-subject');
    var brief = $('#ppa-brief');
    var genre = $('#ppa-genre');
    var tone = $('#ppa-tone');
    var wc = $('#ppa-word-count');

    var payload = {
      subject: subject ? subject.value : '',
      brief: brief ? brief.value : '',
      genre: genre ? genre.value : '',
      tone: tone ? tone.value : '',
      word_count: wc ? Number(wc.value || 0) : 0
    };
    return payload;
  }

  function apiPost(action, data) {
    var url = getAjaxUrl();
    var nonce = getNonce();

    var qs = url.indexOf('?') === -1 ? '?' : '&';
    var endpoint = url + qs + 'action=' + encodeURIComponent(action);

    var headers = { 'Content-Type': 'application/json' };
    if (nonce) headers['X-PPA-Nonce'] = nonce;

    console.info('PPA: POST', action, '→', endpoint);
    return fetch(endpoint, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(data || {}),
      credentials: 'same-origin'
    })
      .then(function (res) {
        var ct = (res.headers.get('content-type') || '').toLowerCase();
        return res.text().then(function (text) {
          // Try to parse JSON; if not JSON, wrap raw text.
          var body = ct.indexOf('application/json') !== -1 ? jsonTryParse(text) : jsonTryParse(text);
          return { ok: res.ok, status: res.status, body: body, raw: text, contentType: ct };
        });
      })
      .catch(function (err) {
        console.info('PPA: fetch error', err);
        return { ok: false, status: 0, body: { error: String(err) }, raw: '', contentType: '' };
      });
  }

  // Tolerant extraction of HTML from various JSON shapes
  function pickHtmlFromResponseBody(body) {
    if (!body || typeof body !== 'object') return '';
    if (typeof body.html === 'string') return body.html;
    if (body.result && typeof body.result.html === 'string') return body.result.html;
    if (body.data && typeof body.data.html === 'string') return body.data.html;
    if (typeof body.content === 'string') return body.content;
    if (typeof body.preview === 'string') return body.preview;
    if (typeof body.raw === 'string') return body.raw; // last resort if server returned non-JSON
    return '';
  }

  // ---- UI Elements ---------------------------------------------------------

  var btnPreview = $('#ppa-preview');
  var btnDraft = $('#ppa-draft');
  var btnPublish = $('#ppa-publish');

  // ---- Events --------------------------------------------------------------

  if (btnPreview) {
    btnPreview.addEventListener('click', function (ev) {
      ev.preventDefault();
      console.info('PPA: Preview clicked');
      var payload = buildPayload();

      apiPost('ppa_preview', payload).then(function (res) {
        var html = pickHtmlFromResponseBody(res.body);

        // Provider tracing (Improvement #1) — sniff provider marker and log it. // CHANGED:
        var provider = extractProviderFromHtml(html); // CHANGED:
        if (provider) { // CHANGED:
          console.info('PPA: provider=' + provider); // CHANGED:
        } else { // CHANGED:
          console.info('PPA: provider=(unknown)'); // CHANGED:
        } // CHANGED:

        if (html) {
          setPreview(html);
          return;
        }

        // If no HTML, surface a friendly message in the pane
        setPreview('<p><em>Preview did not return HTML content. Check logs.</em></p>');
        console.info('PPA: preview response lacked HTML', res);
      });
    });
  }

  if (btnDraft) {
    btnDraft.addEventListener('click', function (ev) {
      ev.preventDefault();
      console.info('PPA: Save Draft clicked');
      var payload = buildPayload();
      payload.target_sites = ['draft'];

      apiPost('ppa_store', payload).then(function (res) {
        var msg =
          (res.body && (res.body.message || (res.body.result && res.body.result.message))) ||
          'Draft request sent.';
        if (!res.ok) {
          alert('Draft failed (' + res.status + '): ' + msg);
          console.info('PPA: draft failed', res);
          return;
        }
        alert('Draft saved: ' + msg);
        console.info('PPA: draft success', res);
      });
    });
  }

  if (btnPublish) {
    btnPublish.addEventListener('click', function (ev) {
      ev.preventDefault();
      console.info('PPA: Publish clicked');
      var payload = buildPayload();
      payload.target_sites = ['publish'];

      // Confirm publish (kept as alert/confirm for now; inline notices planned in #4)
      /* eslint-disable no-alert */
      if (!window.confirm('Are you sure you want to publish this content now?')) {
        console.info('PPA: publish canceled by user');
        return;
      }
      /* eslint-enable no-alert */

      apiPost('ppa_store', payload).then(function (res) {
        var msg =
          (res.body && (res.body.message || (res.body.result && res.body.result.message))) ||
          'Publish request sent.';
        if (!res.ok) {
          alert('Publish failed (' + res.status + '): ' + msg);
          console.info('PPA: publish failed', res);
          return;
        }
        alert('Published: ' + msg);
        console.info('PPA: publish success', res);
      });
    });
  }

  console.info('PPA: admin.js initialized');
})();
